# High-Level Design: Remove Root and WSL UNC Path Support

**Date**: 2025-12-11
**Version**: 1.0
**Status**: Draft
**Author**: Claude Code / Arthur

---

## 1. Executive Summary

This document describes two enhancements to the mdmcp policy system:

1. **Remove Root**: Add CLI support for removing allowed directory paths from the policy
2. **WSL UNC Path Support**: Introduce a three-tier network filesystem policy that distinguishes between local WSL paths (`\\wsl$\...` or `\\wsl.localhost\...`) and remote network paths

These changes improve policy management flexibility and enable secure access to WSL filesystems from Windows without compromising the network filesystem security model.

---

## 2. Feature 1: Remove Root

### 2.1 Problem Statement

Currently, `mdmcpcfg policy add-root <path>` allows adding allowed roots, but there is no corresponding command to remove them. Users must manually edit the policy YAML to remove entries, which is error-prone and inconsistent with the CLI-first approach.

### 2.2 Requirements

| ID | Requirement | Priority |
|----|-------------|----------|
| RR-1 | CLI command to remove a path from `allowed_roots` | Must |
| RR-2 | Option to also remove corresponding `write_rules` entry | Must |
| RR-3 | Idempotent operation (no error if path doesn't exist) | Should |
| RR-4 | Confirmation message indicating what was removed | Must |
| RR-5 | Validation that policy remains valid after removal | Should |

### 2.3 CLI Design

```
mdmcpcfg policy remove-root <path> [--include-write-rule]
```

**Arguments:**
- `<path>` (required): The path to remove from `allowed_roots`. Matched by exact string comparison against existing entries.

**Options:**
- `--include-write-rule` / `-w`: Also remove any `write_rules` entry matching this path

**Examples:**
```bash
# Remove read-only root
mdmcpcfg policy remove-root "C:/Users/me/old-project"

# Remove root and its write rule
mdmcpcfg policy remove-root "C:/Users/me/old-project" --include-write-rule

# Alias for convenience (matches add-root --write)
mdmcpcfg policy remove-root "C:/Users/me/old-project" -w
```

### 2.4 Implementation Details

#### 2.4.1 New CLI Subcommand

Add to `mdmcpcfg/src/main.rs` `PolicyCommands` enum:

```rust
/// Remove an allowed root directory
RemoveRoot {
    /// Path to remove from allowed roots
    path: String,
    /// Also remove any write rule for this path
    #[arg(long, short = 'w')]
    include_write_rule: bool,
},
```

#### 2.4.2 New Function in `policy.rs`

Location: `mdmcpcfg/src/commands/policy.rs`

```rust
/// Remove an allowed root directory from the policy
pub async fn remove_root(path: String, include_write_rule: bool) -> Result<()> {
    let paths = Paths::new()?;

    if !paths.policy_file.exists() {
        bail!(
            "Policy file not found: {}. Run 'mdmcpcfg install' first.",
            paths.policy_file.display()
        );
    }

    let content = read_file(&paths.policy_file)?;
    let mut policy: Value =
        serde_yaml::from_str(&content).context("Failed to parse policy file")?;

    let mut removed_root = false;
    let mut removed_write_rule = false;

    // Remove from allowed_roots
    if let Some(allowed_roots) = policy
        .get_mut("allowed_roots")
        .and_then(|v| v.as_sequence_mut())
    {
        let original_len = allowed_roots.len();
        allowed_roots.retain(|v| v.as_str() != Some(&path));
        removed_root = allowed_roots.len() < original_len;
    }

    // Optionally remove from write_rules
    if include_write_rule {
        if let Some(write_rules) = policy
            .get_mut("write_rules")
            .and_then(|v| v.as_sequence_mut())
        {
            let original_len = write_rules.len();
            write_rules.retain(|rule| {
                rule.get("path")
                    .and_then(|p| p.as_str())
                    .map(|p| p != path)
                    .unwrap_or(true)
            });
            removed_write_rule = write_rules.len() < original_len;
        }
    }

    // Report results
    if removed_root {
        println!("âœ… Removed allowed root: {}", path);
    } else {
        println!("â„¹ï¸  Root not found: {}", path);
    }

    if include_write_rule {
        if removed_write_rule {
            println!("âœ… Removed write rule for: {}", path);
        } else {
            println!("â„¹ï¸  Write rule not found for: {}", path);
        }
    }

    // Save if any changes were made
    if removed_root || removed_write_rule {
        let updated_content =
            serde_yaml::to_string(&policy).context("Failed to serialize updated policy")?;
        write_file(&paths.policy_file, &updated_content)?;
        println!("âœ“ Policy file updated: {}", paths.policy_file.display());
    }

    Ok(())
}
```

#### 2.4.3 Path Matching Strategy

The implementation uses **exact string matching** against the path as stored in the policy file. This is consistent with how `add_root` stores paths and avoids canonicalization issues where:
- User adds `~/projects` but policy stores expanded path
- User tries to remove with different path form

**Future Enhancement**: Consider optional `--fuzzy` flag that canonicalizes both the input and stored paths before comparison.

### 2.5 Test Cases

| Test | Description | Expected |
|------|-------------|----------|
| TC-RR-1 | Remove existing root | Root removed, success message |
| TC-RR-2 | Remove non-existent root | Info message, no error |
| TC-RR-3 | Remove root with `--include-write-rule` | Both root and write rule removed |
| TC-RR-4 | Remove root when write rule doesn't exist | Root removed, info for missing write rule |
| TC-RR-5 | Policy file doesn't exist | Error with install hint |

---

## 3. Feature 2: WSL UNC Path Support

### 3.1 Problem Statement

The current network filesystem detection on Windows treats all UNC paths (`\\...`) as network filesystems and blocks them when `deny_network_fs: true`. However, WSL paths (`\\wsl$\Ubuntu\...` or `\\wsl.localhost\Ubuntu\...`) are local to the machine and should be treated differently from true network paths like `\\server\share`.

Users need to:
1. Access WSL filesystems from Windows-hosted mdmcp server
2. Maintain security by blocking remote network filesystems
3. Have granular control over what types of paths are allowed

### 3.2 WSL Path Formats

Windows supports accessing WSL filesystems via UNC paths:

| Format | Example | Notes |
|--------|---------|-------|
| `\\wsl$\<distro>\...` | `\\wsl$\Ubuntu\home\user` | Legacy format, still widely used |
| `\\wsl.localhost\<distro>\...` | `\\wsl.localhost\Ubuntu\home\user` | Newer format (Windows 11+) |

Both formats provide access to the **local** WSL installation and should be distinguishable from remote network shares.

### 3.3 Requirements

| ID | Requirement | Priority |
|----|-------------|----------|
| WU-1 | Distinguish WSL UNC paths from remote network UNC paths | Must |
| WU-2 | New policy field to control network/WSL access modes | Must |
| WU-3 | Backward compatibility with existing `deny_network_fs` | Must |
| WU-4 | Support both `\\wsl$\` and `\\wsl.localhost\` formats | Must |
| WU-5 | Clear error messages indicating why access was denied | Should |
| WU-6 | CLI commands to configure network FS policy | Should |

### 3.4 Policy Schema Design

#### 3.4.1 New Field: `network_fs_policy`

Replace the boolean `deny_network_fs` with a more expressive enum:

```yaml
# New schema
network_fs_policy: "deny_all"  # or "allow_local_wsl" or "allow_all"
```

**Values:**

| Value | Description | Allows WSL | Allows Remote |
|-------|-------------|------------|---------------|
| `deny_all` | Block all network/UNC paths (most secure) | No | No |
| `allow_local_wsl` | Allow local WSL paths only | Yes | No |
| `allow_all` | Allow all network paths (least secure) | Yes | Yes |

#### 3.4.2 Backward Compatibility

The existing `deny_network_fs` field is mapped to the new enum:

| Old Value | New Equivalent |
|-----------|----------------|
| `deny_network_fs: true` | `network_fs_policy: deny_all` |
| `deny_network_fs: false` | `network_fs_policy: allow_all` |

**Migration Strategy:**
1. Both fields are supported during a transition period
2. If both are present, `network_fs_policy` takes precedence
3. When serializing, prefer `network_fs_policy`
4. Deprecation warning when `deny_network_fs` is used alone

#### 3.4.3 Schema Definition

Add to `crates/mdmcp_policy/src/lib.rs`:

```rust
/// Network filesystem access policy
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema, Default, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum NetworkFsPolicy {
    /// Deny all network/UNC paths (most secure, default)
    #[default]
    DenyAll,
    /// Allow local WSL paths (\\wsl$\, \\wsl.localhost\) but deny remote
    AllowLocalWsl,
    /// Allow all network paths (least secure)
    AllowAll,
}
```

Update `Policy` struct:

```rust
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
#[serde(deny_unknown_fields)]
pub struct Policy {
    pub version: u32,

    /// Network filesystem access policy (preferred)
    #[serde(default)]
    pub network_fs_policy: NetworkFsPolicy,

    /// DEPRECATED: Use network_fs_policy instead
    /// Kept for backward compatibility
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deny_network_fs: Option<bool>,

    pub allowed_roots: Vec<String>,
    // ... rest unchanged
}
```

### 3.5 Implementation Details

#### 3.5.1 WSL Path Detection

Add to `mdmcpsrvr/src/fs_safety.rs`:

```rust
/// Check if a path is a local WSL UNC path
/// Returns true for paths like \\wsl$\Ubuntu\... or \\wsl.localhost\Ubuntu\...
fn is_local_wsl_path(path: &Path) -> bool {
    let path_str = path.to_string_lossy();
    let lower = path_str.to_lowercase();

    // Check for \\wsl$ or \\wsl.localhost
    if lower.starts_with("\\\\wsl$\\") || lower.starts_with("\\\\wsl.localhost\\") {
        return true;
    }

    // Also handle forward slash variants that might come from path normalization
    if lower.starts_with("//wsl$/") || lower.starts_with("//wsl.localhost/") {
        return true;
    }

    false
}

/// Classify a UNC path
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum UncPathType {
    /// Local WSL filesystem (\\wsl$\ or \\wsl.localhost\)
    LocalWsl,
    /// Remote network share
    RemoteNetwork,
    /// Not a UNC path
    NotUnc,
}

fn classify_unc_path(path: &Path) -> UncPathType {
    let path_str = path.to_string_lossy();

    // Must start with \\ to be UNC (but not \\?\ which is long path prefix)
    if !path_str.starts_with("\\\\") || path_str.starts_with("\\\\?\\") {
        return UncPathType::NotUnc;
    }

    if is_local_wsl_path(path) {
        UncPathType::LocalWsl
    } else {
        UncPathType::RemoteNetwork
    }
}
```

#### 3.5.2 Updated Network FS Check

Modify `is_network_fs` in `fs_safety.rs` (Windows implementation):

```rust
#[cfg(target_os = "windows")]
pub(crate) fn check_network_fs_access(
    path: &Path,
    policy: NetworkFsPolicy
) -> Result<(), FsError> {
    use NetworkFsPolicy::*;

    match policy {
        AllowAll => return Ok(()),
        DenyAll | AllowLocalWsl => {
            // Check UNC path type
            match classify_unc_path(path) {
                UncPathType::NotUnc => {
                    // Check for mapped network drives
                    if is_mapped_network_drive(path)? {
                        return Err(FsError::NetworkFsDenied {
                            path: path.display().to_string(),
                        });
                    }
                }
                UncPathType::LocalWsl => {
                    if policy == DenyAll {
                        return Err(FsError::WslPathDenied {
                            path: path.display().to_string(),
                        });
                    }
                    // AllowLocalWsl permits this
                }
                UncPathType::RemoteNetwork => {
                    return Err(FsError::NetworkFsDenied {
                        path: path.display().to_string(),
                    });
                }
            }
        }
    }

    Ok(())
}

fn is_mapped_network_drive(path: &Path) -> Result<bool, FsError> {
    use std::ffi::OsStr;
    use std::os::windows::ffi::OsStrExt;

    if let Some(root) = path.ancestors().last() {
        let root_wide: Vec<u16> = OsStr::new(&format!("{}\\", root.display()))
            .encode_wide()
            .chain(std::iter::once(0))
            .collect();

        let drive_type =
            unsafe { windows_sys::Win32::Storage::FileSystem::GetDriveTypeW(root_wide.as_ptr()) };

        // DRIVE_REMOTE = 4
        return Ok(drive_type == 4);
    }

    Ok(false)
}
```

#### 3.5.3 New Error Variant

Add to `FsError` enum:

```rust
#[derive(Error, Debug)]
pub enum FsError {
    // ... existing variants ...

    #[error("WSL path access denied (policy: deny_all): {path}")]
    WslPathDenied { path: String },
}
```

#### 3.5.4 Policy Effective Value Resolution

Add helper to resolve the effective network FS policy:

```rust
impl Policy {
    /// Get the effective network filesystem policy, handling backward compatibility
    pub fn effective_network_fs_policy(&self) -> NetworkFsPolicy {
        // New field takes precedence
        if self.network_fs_policy != NetworkFsPolicy::default() {
            return self.network_fs_policy.clone();
        }

        // Fall back to legacy field
        match self.deny_network_fs {
            Some(true) => NetworkFsPolicy::DenyAll,
            Some(false) => NetworkFsPolicy::AllowAll,
            None => NetworkFsPolicy::DenyAll, // Default to most secure
        }
    }
}
```

### 3.6 CLI Enhancements

#### 3.6.1 New Command: `policy set-network-fs`

```
mdmcpcfg policy set-network-fs <mode>
```

**Arguments:**
- `<mode>`: One of `deny-all`, `allow-local-wsl`, `allow-all`

**Examples:**
```bash
# Most secure (default)
mdmcpcfg policy set-network-fs deny-all

# Allow WSL paths only
mdmcpcfg policy set-network-fs allow-local-wsl

# Allow all (not recommended)
mdmcpcfg policy set-network-fs allow-all
```

#### 3.6.2 Policy Show Enhancement

Update `policy show` to display the effective network FS policy:

```
ðŸ“Š Policy Summary:
   Version: 1
   Network FS policy: allow-local-wsl
     â”œâ”€ Remote network shares: DENIED
     â””â”€ Local WSL paths (\\wsl$\, \\wsl.localhost\): ALLOWED
   Allowed roots: 3 entries
   ...
```

### 3.7 Security Considerations

| Concern | Mitigation |
|---------|------------|
| WSL path traversal | Canonical path resolution still applies; `..` escapes are blocked |
| WSL distro spoofing | Rely on Windows kernel for UNC path routing |
| Accidental allow-all | Default is `deny_all`; CLI warns when setting `allow-all` |
| Config migration | Warn on deprecated field usage |

### 3.8 Test Cases

| Test | Description | Expected |
|------|-------------|----------|
| TC-WU-1 | `deny_all` blocks WSL path | Access denied with WslPathDenied |
| TC-WU-2 | `deny_all` blocks remote UNC | Access denied with NetworkFsDenied |
| TC-WU-3 | `allow_local_wsl` allows `\\wsl$\...` | Access granted |
| TC-WU-4 | `allow_local_wsl` allows `\\wsl.localhost\...` | Access granted |
| TC-WU-5 | `allow_local_wsl` blocks `\\server\share` | Access denied |
| TC-WU-6 | `allow_all` allows everything | Access granted |
| TC-WU-7 | Backward compat: `deny_network_fs: true` | Equivalent to `deny_all` |
| TC-WU-8 | Backward compat: `deny_network_fs: false` | Equivalent to `allow_all` |
| TC-WU-9 | Both fields present, new takes precedence | Uses `network_fs_policy` value |
| TC-WU-10 | Case insensitivity of WSL prefix | `\\WSL$\...` treated as WSL |

---

## 4. Implementation Plan

### 4.1 Phase 1: Remove Root (Low Risk)

1. Add `RemoveRoot` variant to `PolicyCommands` enum
2. Implement `remove_root()` function in `policy.rs`
3. Wire up CLI in `main.rs`
4. Add unit tests
5. Update README/docs

**Estimated Effort**: 2-3 hours

### 4.2 Phase 2: WSL UNC Support (Medium Risk)

1. Add `NetworkFsPolicy` enum to `mdmcp_policy`
2. Update `Policy` struct with new field and deprecation
3. Add `effective_network_fs_policy()` method
4. Implement WSL path detection in `fs_safety.rs`
5. Update `is_network_fs` to use new classification
6. Add new error variant
7. Add CLI command `policy set-network-fs`
8. Update `policy show` display
9. Add comprehensive tests
10. Update documentation

**Estimated Effort**: 4-6 hours

### 4.3 Version Bump

Both features warrant a minor version bump (e.g., 0.6.2 â†’ 0.7.0) due to:
- New CLI commands
- Policy schema changes (additive, backward compatible)

---

## 5. Open Questions

1. **Path normalization for remove-root**: Should we canonicalize paths before comparison, or require exact string match?
   - **Recommendation**: Start with exact match; add `--fuzzy` option later if needed

2. **WSL distro validation**: Should we validate that the WSL distro in the path actually exists?
   - **Recommendation**: No; let the OS handle it. Invalid distros will fail at file access time.

3. **Migration tool**: Should we provide a command to migrate `deny_network_fs` to `network_fs_policy`?
   - **Recommendation**: Not initially; the backward compatibility layer handles this transparently.

---

## 6. Appendix

### A. Example Policy with New Fields

```yaml
version: 1

# New: three-tier network FS control
network_fs_policy: allow_local_wsl

allowed_roots:
  - "C:\\Users\\Arthur\\projects"
  - "\\\\wsl.localhost\\Ubuntu\\home\\arthur\\code"  # WSL path now allowed

write_rules:
  - path: "C:\\Users\\Arthur\\projects\\scratch"
    recursive: true
    max_file_bytes: 10000000
    create_if_missing: true

commands:
  - id: "ls"
    exec: "C:\\Windows\\System32\\cmd.exe"
    args:
      fixed: ["/C", "dir"]
    cwd_policy: within_root
    timeout_ms: 10000
    max_output_bytes: 50000
    platform: ["windows"]
    allow_any_args: true

logging:
  level: info

limits:
  max_read_bytes: 20000000
  max_cmd_concurrency: 3
```

### B. Error Message Examples

**WSL path denied (deny_all mode):**
```json
{
  "code": -32001,
  "message": "WSL path access denied (policy: deny_all): \\\\wsl$\\Ubuntu\\home\\user\\file.txt",
  "data": {
    "method": "fs.read",
    "reason": "policyDenied",
    "rule": "wslPathDenied",
    "path": "\\\\wsl$\\Ubuntu\\home\\user\\file.txt"
  }
}
```

**Remote network path denied (allow_local_wsl mode):**
```json
{
  "code": -32001,
  "message": "Network filesystem access denied: \\\\server\\share\\file.txt",
  "data": {
    "method": "fs.read",
    "reason": "policyDenied",
    "rule": "networkFsDenied",
    "path": "\\\\server\\share\\file.txt"
  }
}
```

### C. References

- [WSL File System Access](https://learn.microsoft.com/en-us/windows/wsl/filesystems)
- [UNC Path Format](https://learn.microsoft.com/en-us/dotnet/standard/io/file-path-formats#unc-paths)
- Current implementation: `mdmcpsrvr/src/fs_safety.rs:440-469`
